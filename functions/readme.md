## 函数

### 编写简短的函数
在处理代码时, 你可能会发现复杂的长函数. 不要害怕修改现有代码: 如果证实这些代码使用 / 调试起来很困难, 或者你只需要使用其中的一小段代码, 考虑将其分割为更加简短并易于管理的若干函数。  

### 函数返回类型的后置语法
在常规语法不便于书写和阅读时，可以考虑返回值后置语法（但不建议在任何情况下都使用后置返回类型）。  
在C++11之前，函数声明时只能将返回类型置于函数名前：  
``` c++
int foo(int x);
```

在C++11中，引入了一种新语法，可以在函数名前使用auto关键字，然后后置返回类型：  
``` c++
auto foo(int x) -> int;
```

后置返回类型是显是显式指定Lambda表达式返回值的位移方式，在某些情况下，编译器无法自动推到Lambda表达式的返回值，即使能够自动推到，显式指定返回类型也可以让读者更明了。  
在以及出现了的函数列表之后指定返回类型，能够让书写更简单，也更易读，尤其式返回类型依赖于模板参数时：  
``` c++
template <class T, class U> auto add(T t, U u) -> decltype(t + u);

//与常规写法做对比
template <class T, class U> decltype(declval<T&>() + declval<U&>()) add(T t, U u);
```

### 参数顺序
函数参数的顺序为：输入参数在前，输出参数在后。  
其中输入参数一般为值参或为`const`引用，输出参数一般为非`const`指针。  
在为函数添加新参数时，也要需要参考这条规则。  
这条规则是可以根据实际情况变通的。  

### 引用参数
所有按引用传递的参数必须加上`const`。  
输入参数可以是`const`指针，但不能为非`const`引用参数，因为这样容易引起误解（引用在语法上是值变量却具有指针的语义）。  
输入参数在大多数情况下使用`const T&`而非`const T*`，除非对输入另有处理。  

### 函数重载
如果函数单靠不同的参数类型进行重载而参数数量不变，就要求读者十分熟悉C++的匹配规则；另外如果派生类只重载了某个函数的部分变体，读者会在继承方面感到困惑。若要使用重载函数，应该让读者能确定调用点使用的是函数的哪个重载。所以打算重载一个函数前，可以先试试在函数名中加上参数信息，例如用`AppendString()`和`AppendInt()`取代一口气重载多个`Append()`。  
如果函数重载只是为了支持不同数量的同一类型参数，可以优先使用`std::vector`，这样使用者可以方便地使用列表初始化来传递参数。  

### 缺省参数
有些函数一般情况下使用默认参数，但是有时候又需要使用非默认参数，缺省参数为这样的情形提供了便利，使程序员不需要极少的例外情况编写大量的函数。和函数重载相比, 缺省参数的语法更简洁明了，减少了大量的样板代码，也更好地区别了 “必要参数” 和 “可选参数”。  
但是缺省参数实际上是函数重载语义的另一种实现方式，因此所有**不应该使用函数重载的理由**也使用与缺省参数。  
缺省参数是在每个调用点都要进行重新求值的，这会造成生成的代码迅速膨胀。作为读者， 一般来说也更希望缺省的参数在声明时就已经被固定了，而不是在每次调用时都可能会有不同的取值。  
缺省参数会影响函数指针，导致函数签名和调用点的签名不易hi，而函数重载没有这个问题。  
对于虚函数，不允许使用缺省函数，因为在虚函数中缺省函数不一定能正常工作，如果每个调用点缺省参数的只都又可能不同，这种情况下缺省参数也不允许使用（例如，不要写`void f(int n = counter++);`这样的代码）。  
在其他情况下，缺省参数对可读性的提升原因超过以上提到的缺点的话，则可以使用。  
