## 类

### 构造函数
在构造函数中可以进行各种初始化操作。  
在构造函数中不允许调用虚函数。  
[构造函数的缺点](https://zh-google-styleguide。readthedocs。io/en/latest/google-cpp-styleguide/classes/#id2)  

### 隐式类型转换
尽量不要定义隐式类型转换：  
- 影视转换会隐藏类型不匹配的错误，有时，目的类型不符合用户期望，甚至用户每一只到发生了类型转换。  
- 隐式类型转换会让代码难以阅读，尤其是又函数重载时。  
- 单参数构造函数有时会被无意用作隐式类型转换。  

`explicit`关键字可用于构造函数或类型转换操作符，一爆炸只有当目的类型被显式声明是才进行类型转换。这不仅作用于隐式类型转换，还作用于C++11的列表初始化语法：  
``` c++
class Foo {
    explicit Foo(int x，double y);
    。。。
};

void Func(Foo f);
```

此时下面的代码是**不允许**的：  
```c++
Func({42，3。14});  // 错误
```

### 可拷贝类型和可移动类型
可拷贝类型允许对象在初始化时得到来自相同类型的另一对象的值，或在赋值时被赋予相同类型的另一对象的值，同时不改变源对象的值。对于用户定义的类型，拷贝操作一般通过拷贝构造函数与拷贝赋值操作符定义。string 类型就是一个可拷贝类型的例子。  
可移动类型允许对象在初始化时得到来自相同类型的临时对象的值，或在赋值时被赋予相同类型的临时对象的值 (因此所有可拷贝对象也是可移动的)。  `std::unique_ptr<int>` 就是一个可移动但不可复制的对象的例子。对于用户定义的类型，移动操作一般是通过移动构造函数和移动赋值操作符实现的。  
拷贝 / 移动构造函数在某些情况下会被编译器隐式调用。例如，通过传值的方式传递对象。  
拷贝构造函数时隐式调用的，这些调用很容易被忽略，使人迷惑。同时这在一定程度上会故意过度拷贝，导致性能问题。  
如果你的类型需要，就让他支持拷贝/移动，否则就把隐式产生的拷贝和构造函数禁用掉。如果类型可拷贝，并且移动操作的效率高于拷贝，那么就把移动的两个操作（移动构造函数和赋值操作）也定义出来，如果类型不可拷贝，但是移动操作的正确性显而易见，那么可以只为这个类型定义移动的两个操作。  
``` c++
class Foo {
public:
    Foo(Foo&& other) : field_(other。field) {}
    //差，值定义了移动构造函数，没有定义相应的赋值运算符

private:
    Field field_;
};
```

由于存在对象切割的风险，请不要为任何又派生类的对象提供赋值操作或拷贝/移动构造函数（当然也不要继承这样的成员函数的类）。如果你的基类需要可复制的熟悉，请提供`public virtual Clone()`和`protected`的拷贝构造函数以供派生类实现。  
如果你的类不需要拷贝/移动操作，请显式在`public`域使用`= delete`禁用之。  
``` c++
MyClass(const MyClass&) = delete;
MyClass& operator=(const MyClass&) = delete;
```

### 结构体 vs。类
在C++中`struct`和`calss`关键字的含义几乎一样。我们为这两个关键字添加我们自己的语义理解，以便为定义的数据类型选择合适的关键字。  
`struct`用来定义包含数据的被动式对象，也可以包含相关的常量，但除了存取数据成员之外，没有别的函数功能。并且存取功能是通过直接访问位域，而非函数调用。除了构造函数，析构函数，`Initialize()`，`Reset()`，`Validate()` 等类似的用于设定数据成员的函数外，不能提供其它功能的函数。  
如果需要更多的函数功能，`class`更适合。如果拿不准，就用`class`。  
为了和STL保持一致，对于仿函数等特性可以不用`class`而是使用`struct`。  

### 继承
所有继承必须是`public`的。如果你想使用私有继承，你应该替换成把基类的实例作为成员对象的方式。  
不要过度使用实现继承。组合常常更合适一些。尽量做到只在“是一个”(“is-a”，YuleFox 注: 其他“has-a”情况下请使用组合) 的情况下使用继承: 如果Bar的确“是一种Foo，Bar才能继承Foo。  
必要的话，析构函数声明为`virtual`。如果你的类有虚函数，则析构函数也应该为虚函数。  
对于可能被子类访问的成员函数，不要过度使用`protected`关键字。注意，数据成员都必须是私有的。  
对于重载的虚函数或虚析构函数，使用`override`，或 (较不常用的) `final` 关键字显式地进行标记。较早 (早于 C++11) 的代码可能会使用 `virtual` 关键字作为不得已的选项。因此，在声明重载时，请使用 `override`，`final` 或 `virtual` 的其中之一进行标记。标记为 `override` 或 `final` 的析构函数如果不是对基类虚函数的重载的话，编译会报错，这有助于捕获常见的错误。这些标记起到了文档的作用，因为如果省略这些关键字，代码阅读者不得不检查所有父类，以判断该函数是否是虚函数。  

### 多重继承
真正需要用到多重实现继承的情况少之又少。只在以下情况我们才允许多重继承：最多只有一个基类是非抽象类；其它基类都是以`Interface`为后缀的纯接口类。  

### 接口
当一个类满足下面要求时，称为纯接口：  
- 只有纯虚函数（`=0`）和静态函数（除了析构函数）。  
- 没有非静态数据成员。  
- 没有定义任何构造函数，如果又，也不能带参数，并且必须为`protected`。  
- 如果他是子类，必须继承自以类名以`Interface`结尾并且满足上述条件的基类。  

为了保证接口类的所有实现可被正确销毁，必须为之声明虚析构函数。  

### 运算符重载
尽量避免使用运算符重载，特别是`&&`、`||`、`,`和一元操作符`&`。  
如果你定义了一个运算符，请将其相关且有意义的运算符都进行定义，并且保证这些定义的语义是一致的。例如，如果你重载了`<`，那么请将所有的比较运算符都进行重载, 并且保证对于同一组参数，`<`和`>`不会同时返回`true`。  
但也不要为了避免重载运算符而走机端，比如，应当定义`==`、`=`和`<<`，而不是`Equals()`、`CopyFrom()`或`PrintTo()`。  

### 存取控制
将**所有**数据成员声明为`private`，除非是`static const`类型成员（遵循常量命名规则）。  

### 声明顺序
在各个部分中，建议将类似的声明放在一起，并且建议以如下的顺序：类型（包括 typedef，using和嵌套的结构体与类），常量，工厂函数，构造函数，赋值运算符，析构函数，其它函数，数据成员。  
不要将大段的函数定义内联在类定义中。通常，只有那些普通的，或性能关键且短小的函数可以内联在类定义中。  
